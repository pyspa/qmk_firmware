#include QMK_KEYBOARD_H

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case LCTL_T(KC_A):
            return 300;
        case LCTL_T(KC_Z):
            return 300;
        case LCTL_T(KC_S):
            return 300;
        case LSFT_T(KC_X):
            return 300;
        case LSFT_T(KC_G):
            return 300;
        case LALT_T(KC_C):
            return 300;
        case LT(4,KC_V):
            return 300;
        case LT(3,KC_ENT):
            return 180;
        case LT(2,KC_B):
            return 110;
        case LT(1,KC_N):
            return 140;
        default:
            return TAPPING_TERM;
    }
}

bool get_permissive_hold(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case LCTL_T(KC_A):
            return false;
        case LCTL_T(KC_Z):
            return false;
        case LCTL_T(KC_S):
            return false;
        case LSFT_T(KC_X):
            return false;
        case LSFT_T(KC_G):
            return false;
        case LALT_T(KC_C):
            return false;
        case LT(4,KC_V):
            return false;
        case LT(2,KC_B):
            return false;
        case LT(1,KC_N):
            return true;
        default:
            return true;
    }
}

bool get_tapping_force_hold(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case LT(3,KC_ENT):
            return true;
        case LT(2,KC_B):
            return true;
        case LT(1,KC_N):
            return true;
        case LCTL_T(KC_S):
            return true;
        default:
            return false;
    }
}

bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case LCTL_T(KC_A):
            return true;
        case LCTL_T(KC_Z):
            return true;
        case LCTL_T(KC_S):
            return true;
        case LSFT_T(KC_X):
            return true;
        case LSFT_T(KC_G):
            return true;
        case LALT_T(KC_C):
            return true;
        case LT(4,KC_V):
            return true;
        case LT(2,KC_B):
            return false;
        case LT(1,KC_N):
            return false;
        default:
            return false;
    }
}

bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case LCTL_T(KC_S):
            return true;
        default:
            return false;
    }
}


// Tap Dance declarations
enum {
      TD_Q_ESC,
      TD_CD,
      TD_ST,
      TD_O_HY,
};

void dance_q_finished(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        register_code16(KC_Q);
    } else {
        register_code(KC_ESCAPE);
    }
}

void dance_q_reset(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        unregister_code16(KC_Q);
    } else {
        unregister_code(KC_ESCAPE);
    }
}

void dance_cd_finished(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        register_code16(KC_COMMA);
    } else {
      register_code(KC_DOT);
    }
}

void dance_cd_reset(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        unregister_code16(KC_COMMA);
    } else {
        unregister_code(KC_DOT);
    }
}

void dance_st_finished(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        register_code16(KC_SPACE);
    } else {
      register_code(KC_TAB);
    }
}

void dance_st_reset(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        unregister_code16(KC_SPACE);
    } else {
        unregister_code(KC_TAB);
    }
}

void dance_ohy_finished(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        register_code16(KC_O);
    } else {
      register_code(KC_MINUS);
    }
}

void dance_ohy_reset(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        unregister_code16(KC_O);
    } else {
        unregister_code(KC_MINUS);
    }
}

// All tap dance functions would go here. Only showing this one.
qk_tap_dance_action_t tap_dance_actions[] = {
    [TD_Q_ESC] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, dance_q_finished, dance_q_reset),
    [TD_CD] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, dance_cd_finished, dance_cd_reset),
    [TD_ST] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, dance_st_finished, dance_st_reset),
    [TD_O_HY] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, dance_ohy_finished, dance_ohy_reset),
};

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
  [0] = LAYOUT_split(
    TD(TD_Q_ESC), KC_W,         KC_E,         KC_R,         KC_T,        KC_Y,        KC_U,    KC_I,    TD(TD_O_HY),    KC_BSPC,
    LCTL_T(KC_A), LCTL_T(KC_S), KC_D,         KC_F,         LSFT_T(KC_G),KC_H,        KC_J,    KC_K,    KC_L,           LT(5,KC_P),
    LCTL_T(KC_Z), LSFT_T(KC_X), LALT_T(KC_C), LT(4,KC_V),   LT(2,KC_B),  LT(1,KC_N),  KC_M,    TD(TD_CD),LSFT_T(KC_DOT), LT(3,KC_ENT)),

  [1] = LAYOUT_split(
    KC_1,         KC_2,         KC_3,         KC_4,         KC_5,        KC_6,        KC_7,    KC_8,    KC_9,           KC_0,
    KC_TAB,       KC_TRNS,      KC_TRNS,      KC_TRNS,      KC_SPC,      KC_SPC,      KC_SPC,  KC_ASTR, KC_MINS,        KC_DEL,
    KC_LCTL,      KC_LSFT,      KC_LALT,      KC_SPC,       TD(TD_ST),   LT(1,KC_NO), KC_SPC,  KC_SPC,  KC_SPC,         LALT(KC_GRV)),

  [2] = LAYOUT_split(
    KC_EXLM,      KC_AT,        KC_HASH,      KC_DLR,       KC_PERC,     KC_CIRC,     KC_AMPR, KC_ASTR, KC_MINS,        KC_EQL,
    KC_TAB,       KC_GRV,       KC_TILD,      LALT(KC_GRV), LALT(KC_GRV),KC_LPRN,     KC_RPRN, KC_SCLN, KC_QUOT,        KC_BSLS,
    KC_LCTL,      KC_LSFT,      KC_LALT,      LALT(KC_GRV), LT(2,KC_NO), KC_LBRC,     KC_RBRC, KC_LT,   KC_GT,          KC_SLSH),

  [3] = LAYOUT_split(
    KC_ESC,       KC_TRNS,      KC_TRNS,      KC_TRNS,      KC_TRNS,     KC_LEFT,     KC_UP,   KC_UP,   KC_UP,          KC_ESC,
    KC_TAB,       KC_TRNS,      KC_TRNS,      KC_TRNS,      KC_TRNS,     KC_LEFT,     KC_LEFT, KC_UP,   KC_RIGHT,       KC_TRNS,
    KC_LCTL,      KC_LSFT,      KC_LALT,      KC_TRNS,      KC_TRNS,     KC_LEFT,     KC_LEFT, KC_DOWN, KC_RGHT,        LT(3,KC_NO)),

  [4] = LAYOUT_split(
    KC_EXLM,      KC_AT,        KC_HASH,      KC_DLR,       KC_PERC,     KC_CIRC,     KC_AMPR, KC_ASTR, KC_MINS,        KC_EQL,
    KC_TAB,       KC_TRNS,      KC_TRNS,      KC_TRNS,      KC_TRNS,     KC_LPRN,     KC_RPRN, KC_LCBR, KC_RCBR,        KC_BSLS,
    KC_LCTL,      KC_LSFT,      KC_LALT,      LT(4,KC_NO),  KC_TRNS,     KC_LBRC,     KC_RBRC, KC_LT,   KC_GT,          KC_GRV),

  [5] = LAYOUT_split(
    KC_F1,        KC_F2,        KC_F3,        KC_F4,       KC_F5,        KC_F6,       KC_F7,   KC_F8,   KC_F9,          KC_F10,
    KC_F11,       KC_F12,       KC_TRNS,      KC_TRNS,     KC_TRNS,      KC_TRNS,     KC_TRNS, KC_TRNS, KC_TRNS,        LT(5,KC_NO),
    KC_LCTL,      KC_LSFT,      KC_LALT,      KC_TRNS,      KC_TRNS,     RESET,       KC_TRNS, KC_TRNS, KC_TRNS,        KC_TRNS)
};
